// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package graph

import (
	"bytes"
	"context"
	"embed"
	"errors"
	"fmt"
	"sync/atomic"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	"github.com/BalkanID-University/vit-2026-capstone-internship-hiring-task-joel2607/models"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		schema:     cfg.Schema,
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Schema     *ast.Schema
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	DeduplicatedContent() DeduplicatedContentResolver
	File() FileResolver
	FileSharing() FileSharingResolver
	Folder() FolderResolver
	Mutation() MutationResolver
	Query() QueryResolver
	User() UserResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	AuthResponse struct {
		Token func(childComplexity int) int
		User  func(childComplexity int) int
	}

	DeduplicatedContent struct {
		CreatedAt      func(childComplexity int) int
		ID             func(childComplexity int) int
		ReferenceCount func(childComplexity int) int
		SHA256Hash     func(childComplexity int) int
		UpdatedAt      func(childComplexity int) int
	}

	File struct {
		CreatedAt           func(childComplexity int) int
		DeduplicatedContent func(childComplexity int) int
		DeduplicationID     func(childComplexity int) int
		DownloadCount       func(childComplexity int) int
		FileName            func(childComplexity int) int
		Folder              func(childComplexity int) int
		ID                  func(childComplexity int) int
		IsPublic            func(childComplexity int) int
		MIMEType            func(childComplexity int) int
		ParentFolderID      func(childComplexity int) int
		Size                func(childComplexity int) int
		Tags                func(childComplexity int) int
		UpdatedAt           func(childComplexity int) int
		User                func(childComplexity int) int
		UserID              func(childComplexity int) int
	}

	FileSharing struct {
		CreatedAt        func(childComplexity int) int
		File             func(childComplexity int) int
		FileID           func(childComplexity int) int
		ID               func(childComplexity int) int
		PermissionLevel  func(childComplexity int) int
		SharedWithUser   func(childComplexity int) int
		SharedWithUserID func(childComplexity int) int
		UpdatedAt        func(childComplexity int) int
	}

	Folder struct {
		CreatedAt      func(childComplexity int) int
		FolderName     func(childComplexity int) int
		ID             func(childComplexity int) int
		IsPublic       func(childComplexity int) int
		ParentFolderID func(childComplexity int) int
		UpdatedAt      func(childComplexity int) int
		User           func(childComplexity int) int
		UserID         func(childComplexity int) int
	}

	Mutation struct {
		Register func(childComplexity int, input models.RegisterInput) int
	}

	Query struct {
		Login func(childComplexity int, email string, password string) int
	}

	User struct {
		APIRateLimit   func(childComplexity int) int
		CreatedAt      func(childComplexity int) int
		Email          func(childComplexity int) int
		ID             func(childComplexity int) int
		Role           func(childComplexity int) int
		StorageQuotaMb func(childComplexity int) int
		UpdatedAt      func(childComplexity int) int
		UsedStorageMb  func(childComplexity int) int
		Username       func(childComplexity int) int
	}
}

type executableSchema struct {
	schema     *ast.Schema
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	if e.schema != nil {
		return e.schema
	}
	return parsedSchema
}

func (e *executableSchema) Complexity(ctx context.Context, typeName, field string, childComplexity int, rawArgs map[string]any) (int, bool) {
	ec := executionContext{nil, e, 0, 0, nil}
	_ = ec
	switch typeName + "." + field {

	case "AuthResponse.token":
		if e.complexity.AuthResponse.Token == nil {
			break
		}

		return e.complexity.AuthResponse.Token(childComplexity), true

	case "AuthResponse.user":
		if e.complexity.AuthResponse.User == nil {
			break
		}

		return e.complexity.AuthResponse.User(childComplexity), true

	case "DeduplicatedContent.createdAt":
		if e.complexity.DeduplicatedContent.CreatedAt == nil {
			break
		}

		return e.complexity.DeduplicatedContent.CreatedAt(childComplexity), true

	case "DeduplicatedContent.id":
		if e.complexity.DeduplicatedContent.ID == nil {
			break
		}

		return e.complexity.DeduplicatedContent.ID(childComplexity), true

	case "DeduplicatedContent.referenceCount":
		if e.complexity.DeduplicatedContent.ReferenceCount == nil {
			break
		}

		return e.complexity.DeduplicatedContent.ReferenceCount(childComplexity), true

	case "DeduplicatedContent.sha256Hash":
		if e.complexity.DeduplicatedContent.SHA256Hash == nil {
			break
		}

		return e.complexity.DeduplicatedContent.SHA256Hash(childComplexity), true

	case "DeduplicatedContent.updatedAt":
		if e.complexity.DeduplicatedContent.UpdatedAt == nil {
			break
		}

		return e.complexity.DeduplicatedContent.UpdatedAt(childComplexity), true

	case "File.createdAt":
		if e.complexity.File.CreatedAt == nil {
			break
		}

		return e.complexity.File.CreatedAt(childComplexity), true

	case "File.deduplicatedContent":
		if e.complexity.File.DeduplicatedContent == nil {
			break
		}

		return e.complexity.File.DeduplicatedContent(childComplexity), true

	case "File.deduplicationId":
		if e.complexity.File.DeduplicationID == nil {
			break
		}

		return e.complexity.File.DeduplicationID(childComplexity), true

	case "File.downloadCount":
		if e.complexity.File.DownloadCount == nil {
			break
		}

		return e.complexity.File.DownloadCount(childComplexity), true

	case "File.fileName":
		if e.complexity.File.FileName == nil {
			break
		}

		return e.complexity.File.FileName(childComplexity), true

	case "File.folder":
		if e.complexity.File.Folder == nil {
			break
		}

		return e.complexity.File.Folder(childComplexity), true

	case "File.id":
		if e.complexity.File.ID == nil {
			break
		}

		return e.complexity.File.ID(childComplexity), true

	case "File.isPublic":
		if e.complexity.File.IsPublic == nil {
			break
		}

		return e.complexity.File.IsPublic(childComplexity), true

	case "File.mimeType":
		if e.complexity.File.MIMEType == nil {
			break
		}

		return e.complexity.File.MIMEType(childComplexity), true

	case "File.parentFolderId":
		if e.complexity.File.ParentFolderID == nil {
			break
		}

		return e.complexity.File.ParentFolderID(childComplexity), true

	case "File.size":
		if e.complexity.File.Size == nil {
			break
		}

		return e.complexity.File.Size(childComplexity), true

	case "File.tags":
		if e.complexity.File.Tags == nil {
			break
		}

		return e.complexity.File.Tags(childComplexity), true

	case "File.updatedAt":
		if e.complexity.File.UpdatedAt == nil {
			break
		}

		return e.complexity.File.UpdatedAt(childComplexity), true

	case "File.user":
		if e.complexity.File.User == nil {
			break
		}

		return e.complexity.File.User(childComplexity), true

	case "File.userId":
		if e.complexity.File.UserID == nil {
			break
		}

		return e.complexity.File.UserID(childComplexity), true

	case "FileSharing.createdAt":
		if e.complexity.FileSharing.CreatedAt == nil {
			break
		}

		return e.complexity.FileSharing.CreatedAt(childComplexity), true

	case "FileSharing.file":
		if e.complexity.FileSharing.File == nil {
			break
		}

		return e.complexity.FileSharing.File(childComplexity), true

	case "FileSharing.fileId":
		if e.complexity.FileSharing.FileID == nil {
			break
		}

		return e.complexity.FileSharing.FileID(childComplexity), true

	case "FileSharing.id":
		if e.complexity.FileSharing.ID == nil {
			break
		}

		return e.complexity.FileSharing.ID(childComplexity), true

	case "FileSharing.permissionLevel":
		if e.complexity.FileSharing.PermissionLevel == nil {
			break
		}

		return e.complexity.FileSharing.PermissionLevel(childComplexity), true

	case "FileSharing.sharedWithUser":
		if e.complexity.FileSharing.SharedWithUser == nil {
			break
		}

		return e.complexity.FileSharing.SharedWithUser(childComplexity), true

	case "FileSharing.sharedWithUserId":
		if e.complexity.FileSharing.SharedWithUserID == nil {
			break
		}

		return e.complexity.FileSharing.SharedWithUserID(childComplexity), true

	case "FileSharing.updatedAt":
		if e.complexity.FileSharing.UpdatedAt == nil {
			break
		}

		return e.complexity.FileSharing.UpdatedAt(childComplexity), true

	case "Folder.createdAt":
		if e.complexity.Folder.CreatedAt == nil {
			break
		}

		return e.complexity.Folder.CreatedAt(childComplexity), true

	case "Folder.folderName":
		if e.complexity.Folder.FolderName == nil {
			break
		}

		return e.complexity.Folder.FolderName(childComplexity), true

	case "Folder.id":
		if e.complexity.Folder.ID == nil {
			break
		}

		return e.complexity.Folder.ID(childComplexity), true

	case "Folder.isPublic":
		if e.complexity.Folder.IsPublic == nil {
			break
		}

		return e.complexity.Folder.IsPublic(childComplexity), true

	case "Folder.parentFolderId":
		if e.complexity.Folder.ParentFolderID == nil {
			break
		}

		return e.complexity.Folder.ParentFolderID(childComplexity), true

	case "Folder.updatedAt":
		if e.complexity.Folder.UpdatedAt == nil {
			break
		}

		return e.complexity.Folder.UpdatedAt(childComplexity), true

	case "Folder.user":
		if e.complexity.Folder.User == nil {
			break
		}

		return e.complexity.Folder.User(childComplexity), true

	case "Folder.userId":
		if e.complexity.Folder.UserID == nil {
			break
		}

		return e.complexity.Folder.UserID(childComplexity), true

	case "Mutation.register":
		if e.complexity.Mutation.Register == nil {
			break
		}

		args, err := ec.field_Mutation_register_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.Register(childComplexity, args["input"].(models.RegisterInput)), true

	case "Query.login":
		if e.complexity.Query.Login == nil {
			break
		}

		args, err := ec.field_Query_login_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Login(childComplexity, args["email"].(string), args["password"].(string)), true

	case "User.apiRateLimit":
		if e.complexity.User.APIRateLimit == nil {
			break
		}

		return e.complexity.User.APIRateLimit(childComplexity), true

	case "User.createdAt":
		if e.complexity.User.CreatedAt == nil {
			break
		}

		return e.complexity.User.CreatedAt(childComplexity), true

	case "User.email":
		if e.complexity.User.Email == nil {
			break
		}

		return e.complexity.User.Email(childComplexity), true

	case "User.id":
		if e.complexity.User.ID == nil {
			break
		}

		return e.complexity.User.ID(childComplexity), true

	case "User.role":
		if e.complexity.User.Role == nil {
			break
		}

		return e.complexity.User.Role(childComplexity), true

	case "User.storageQuotaMB":
		if e.complexity.User.StorageQuotaMb == nil {
			break
		}

		return e.complexity.User.StorageQuotaMb(childComplexity), true

	case "User.updatedAt":
		if e.complexity.User.UpdatedAt == nil {
			break
		}

		return e.complexity.User.UpdatedAt(childComplexity), true

	case "User.usedStorageMB":
		if e.complexity.User.UsedStorageMb == nil {
			break
		}

		return e.complexity.User.UsedStorageMb(childComplexity), true

	case "User.username":
		if e.complexity.User.Username == nil {
			break
		}

		return e.complexity.User.Username(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	opCtx := graphql.GetOperationContext(ctx)
	ec := executionContext{opCtx, e, 0, 0, make(chan graphql.DeferredResult)}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputRegisterInput,
	)
	first := true

	switch opCtx.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			var response graphql.Response
			var data graphql.Marshaler
			if first {
				first = false
				ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
				data = ec._Query(ctx, opCtx.Operation.SelectionSet)
			} else {
				if atomic.LoadInt32(&ec.pendingDeferred) > 0 {
					result := <-ec.deferredResults
					atomic.AddInt32(&ec.pendingDeferred, -1)
					data = result.Result
					response.Path = result.Path
					response.Label = result.Label
					response.Errors = result.Errors
				} else {
					return nil
				}
			}
			var buf bytes.Buffer
			data.MarshalGQL(&buf)
			response.Data = buf.Bytes()
			if atomic.LoadInt32(&ec.deferred) > 0 {
				hasNext := atomic.LoadInt32(&ec.pendingDeferred) > 0
				response.HasNext = &hasNext
			}

			return &response
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, opCtx.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
	deferred        int32
	pendingDeferred int32
	deferredResults chan graphql.DeferredResult
}

func (ec *executionContext) processDeferredGroup(dg graphql.DeferredGroup) {
	atomic.AddInt32(&ec.pendingDeferred, 1)
	go func() {
		ctx := graphql.WithFreshResponseContext(dg.Context)
		dg.FieldSet.Dispatch(ctx)
		ds := graphql.DeferredResult{
			Path:   dg.Path,
			Label:  dg.Label,
			Result: dg.FieldSet,
			Errors: graphql.GetErrors(ctx),
		}
		// null fields should bubble up
		if dg.FieldSet.Invalids > 0 {
			ds.Result = graphql.Null
		}
		ec.deferredResults <- ds
	}()
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(ec.Schema()), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(ec.Schema(), ec.Schema().Types[name]), nil
}

//go:embed "schema.graphql"
var sourcesFS embed.FS

func sourceData(filename string) string {
	data, err := sourcesFS.ReadFile(filename)
	if err != nil {
		panic(fmt.Sprintf("codegen problem: %s not available", filename))
	}
	return string(data)
}

var sources = []*ast.Source{
	{Name: "schema.graphql", Input: sourceData("schema.graphql"), BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)
