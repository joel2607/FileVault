package graphQL

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.80

import (
	"context"
	"encoding/json"
	"fmt"
	"strconv"

	"github.com/99designs/gqlgen/graphql"
	"github.com/BalkanID-University/vit-2026-capstone-internship-hiring-task-joel2607/database"
	"github.com/BalkanID-University/vit-2026-capstone-internship-hiring-task-joel2607/middleware"
	"github.com/BalkanID-University/vit-2026-capstone-internship-hiring-task-joel2607/models"
)

// ID resolves the id field for the DeduplicatedContent type.
// It converts the numeric ID of the content object into a string.
func (r *deduplicatedContentResolver) ID(ctx context.Context, obj *models.DeduplicatedContent) (string, error) {
	return strconv.FormatUint(uint64(obj.ID), 10), nil
}

// CreatedAt resolves the createdAt field for the DeduplicatedContent type.
// It returns the creation timestamp as a string.
func (r *deduplicatedContentResolver) CreatedAt(ctx context.Context, obj *models.DeduplicatedContent) (string, error) {
	return obj.CreatedAt.String(), nil
}

// UpdatedAt resolves the updatedAt field for the DeduplicatedContent type.
// It returns the last update timestamp as a string.
func (r *deduplicatedContentResolver) UpdatedAt(ctx context.Context, obj *models.DeduplicatedContent) (string, error) {
	return obj.UpdatedAt.String(), nil
}

// ReferenceCount resolves the referenceCount field for the DeduplicatedContent type.
// It returns the number of files that point to this specific content.
func (r *deduplicatedContentResolver) ReferenceCount(ctx context.Context, obj *models.DeduplicatedContent) (int32, error) {
	return int32(obj.ReferenceCount), nil
}

// ID resolves the id field for the File type.
// It converts the numeric ID of the file object into a string.
func (r *fileResolver) ID(ctx context.Context, obj *models.File) (string, error) {
	return strconv.FormatUint(uint64(obj.ID), 10), nil
}

// CreatedAt resolves the createdAt field for the File type.
// It returns the creation timestamp as a string.
func (r *fileResolver) CreatedAt(ctx context.Context, obj *models.File) (string, error) {
	return obj.CreatedAt.String(), nil
}

// UpdatedAt resolves the updatedAt field for the File type.
// It returns the last update timestamp as a string.
func (r *fileResolver) UpdatedAt(ctx context.Context, obj *models.File) (string, error) {
	return obj.UpdatedAt.String(), nil
}

// UserID resolves the userId field for the File type.
// It returns the ID of the user who owns the file as a string.
func (r *fileResolver) UserID(ctx context.Context, obj *models.File) (string, error) {
	return strconv.FormatUint(uint64(obj.UserID), 10), nil
}

// User resolves the user field for the File type.
// It retrieves and returns the user who owns the file.
func (r *fileResolver) User(ctx context.Context, obj *models.File) (*models.User, error) {
	var user models.User
	err := r.DB.First(&user, obj.UserID).Error
	return &user, err
}

// Size resolves the size field for the File type.
// It returns the file size in bytes as an integer.
func (r *fileResolver) Size(ctx context.Context, obj *models.File) (int32, error) {
	return int32(obj.Size), nil
}

// DeduplicationID resolves the deduplicationId field for the File type.
// It returns the ID of the associated deduplicated content as a string.
func (r *fileResolver) DeduplicationID(ctx context.Context, obj *models.File) (string, error) {
	return strconv.FormatUint(uint64(obj.DeduplicationID), 10), nil
}

// DeduplicatedContent resolves the deduplicatedContent field for the File type.
func (r *fileResolver) DeduplicatedContent(ctx context.Context, obj *models.File) (*models.DeduplicatedContent, error) {
	var content models.DeduplicatedContent
	err := r.DB.First(&content, obj.DeduplicationID).Error
	return &content, err
}

// DownloadCount resolves the downloadCount field for the File type.
// It returns the number of times the file has been downloaded.
func (r *fileResolver) DownloadCount(ctx context.Context, obj *models.File) (int32, error) {
	return int32(obj.DownloadCount), nil
}

// ParentFolderID resolves the parentFolderId field for the File type.
// It returns the ID of the folder containing this file, or null if it's in the root.
func (r *fileResolver) ParentFolderID(ctx context.Context, obj *models.File) (*string, error) {
	if obj.FolderID == nil {
		return nil, nil
	}
	id := strconv.FormatUint(uint64(*obj.FolderID), 10)
	return &id, nil
}

// Folder resolves the folder field for the File type.
func (r *fileResolver) Folder(ctx context.Context, obj *models.File) (*models.Folder, error) {
	if obj.FolderID == nil {
		return nil, nil
	}
	var folder models.Folder
	err := r.DB.First(&folder, *obj.FolderID).Error
	return &folder, err
}

// ID resolves the id field for the FileSharing type.
// It converts the numeric ID of the sharing record into a string.
func (r *fileSharingResolver) ID(ctx context.Context, obj *models.FileSharing) (string, error) {
	return strconv.FormatUint(uint64(obj.ID), 10), nil
}

// CreatedAt resolves the createdAt field for the FileSharing type.
// It returns the creation timestamp as a string.
func (r *fileSharingResolver) CreatedAt(ctx context.Context, obj *models.FileSharing) (string, error) {
	return obj.CreatedAt.String(), nil
}

// UpdatedAt resolves the updatedAt field for the FileSharing type.
// It returns the last update timestamp as a string.
func (r *fileSharingResolver) UpdatedAt(ctx context.Context, obj *models.FileSharing) (string, error) {
	return obj.UpdatedAt.String(), nil
}

// FileID resolves the fileId field for the FileSharing type.
// It returns the ID of the file being shared as a string.
func (r *fileSharingResolver) FileID(ctx context.Context, obj *models.FileSharing) (string, error) {
	return strconv.FormatUint(uint64(obj.FileID), 10), nil
}

// File resolves the file field for the FileSharing type.
func (r *fileSharingResolver) File(ctx context.Context, obj *models.FileSharing) (*models.File, error) {
	var file models.File
	err := r.DB.First(&file, obj.FileID).Error
	return &file, err
}

// SharedWithUserID resolves the sharedWithUserId field for the FileSharing type.
// It returns the ID of the user with whom the file is shared as a string.
func (r *fileSharingResolver) SharedWithUserID(ctx context.Context, obj *models.FileSharing) (string, error) {
	return strconv.FormatUint(uint64(obj.SharedWithUserID), 10), nil
}

// SharedWithUser resolves the sharedWithUser field for the FileSharing type.
func (r *fileSharingResolver) SharedWithUser(ctx context.Context, obj *models.FileSharing) (*models.User, error) {
	var user models.User
	err := r.DB.First(&user, obj.SharedWithUserID).Error
	return &user, err
}

// ID resolves the id field for the Folder type.
// It converts the numeric ID of the folder object into a string.
func (r *folderResolver) ID(ctx context.Context, obj *models.Folder) (string, error) {
	return strconv.FormatUint(uint64(obj.ID), 10), nil
}

// CreatedAt resolves the createdAt field for the Folder type.
// It returns the creation timestamp as a string.
func (r *folderResolver) CreatedAt(ctx context.Context, obj *models.Folder) (string, error) {
	return obj.CreatedAt.String(), nil
}

// UpdatedAt resolves the updatedAt field for the Folder type.
// It returns the last update timestamp as a string.
func (r *folderResolver) UpdatedAt(ctx context.Context, obj *models.Folder) (string, error) {
	return obj.UpdatedAt.String(), nil
}

// UserID resolves the userId field for the Folder type.
// It returns the ID of the user who owns the folder as a string.
func (r *folderResolver) UserID(ctx context.Context, obj *models.Folder) (string, error) {
	return strconv.FormatUint(uint64(obj.UserID), 10), nil
}

// User resolves the user field for the Folder type.
func (r *folderResolver) User(ctx context.Context, obj *models.Folder) (*models.User, error) {
	var user models.User
	err := r.DB.First(&user, obj.UserID).Error
	return &user, err
}

// ParentFolderID resolves the parentFolderId field for the Folder type.
// It returns the ID of the parent folder, or null if it's a root-level folder.
func (r *folderResolver) ParentFolderID(ctx context.Context, obj *models.Folder) (*string, error) {
	if obj.ParentFolderID == nil {
		return nil, nil
	}
	id := strconv.FormatUint(uint64(*obj.ParentFolderID), 10)
	return &id, nil
}

// Files resolves the files field for the Folder type.
// It retrieves and returns a list of all files located directly within the folder.
func (r *folderResolver) Files(ctx context.Context, obj *models.Folder) ([]*models.File, error) {
	var files []*models.File
	err := r.DB.Where("folder_id = ?", obj.ID).Find(&files).Error
	return files, err
}

// Folders resolves the folders field for the Folder type.
// It retrieves and returns a list of all subfolders located directly within the folder.
func (r *folderResolver) Folders(ctx context.Context, obj *models.Folder) ([]*models.Folder, error) {
	var folders []*models.Folder
	err := r.DB.Where("parent_folder_id = ?", obj.ID).Find(&folders).Error
	return folders, err
}

// ID resolves the id field for the FolderSharing type.
// It converts the numeric ID of the sharing record into a string.
func (r *folderSharingResolver) ID(ctx context.Context, obj *models.FolderSharing) (string, error) {
	return strconv.FormatUint(uint64(obj.ID), 10), nil
}

// CreatedAt resolves the createdAt field for the FolderSharing type.
// It returns the creation timestamp as a string.
func (r *folderSharingResolver) CreatedAt(ctx context.Context, obj *models.FolderSharing) (string, error) {
	return obj.CreatedAt.String(), nil
}

// UpdatedAt resolves the updatedAt field for the FolderSharing type.
// It returns the last update timestamp as a string.
func (r *folderSharingResolver) UpdatedAt(ctx context.Context, obj *models.FolderSharing) (string, error) {
	return obj.UpdatedAt.String(), nil
}

// FileID resolves the fileId field for the FolderSharing type.
// It returns the ID of the file being shared as a string.
func (r *folderSharingResolver) FolderID(ctx context.Context, obj *models.FolderSharing) (string, error) {
	return strconv.FormatUint(uint64(obj.FolderID), 10), nil
}

// Folder resolves the folder field for the FolderSharing type.
func (r *folderSharingResolver) Folder(ctx context.Context, obj *models.FolderSharing) (*models.Folder, error) {
	var folder models.Folder
	err := r.DB.First(&folder, obj.FolderID).Error
	return &folder, err
}

// SharedWithUserID resolves the sharedWithUserId field for the FolderSharing type.
// It returns the ID of the user with whom the folder is shared as a string.
func (r *folderSharingResolver) SharedWithUserID(ctx context.Context, obj *models.FolderSharing) (string, error) {
	return strconv.FormatUint(uint64(obj.SharedWithUserID), 10), nil
}

// SharedWithUser resolves the sharedWithUser field for the FolderSharing type.
func (r *folderSharingResolver) SharedWithUser(ctx context.Context, obj *models.FolderSharing) (*models.User, error) {
	var user models.User
	err := r.DB.First(&user, obj.SharedWithUserID).Error
	return &user, err
}

// Register is the resolver for the register mutation.
// It handles new user registration by calling the AuthService.
func (r *mutationResolver) Register(ctx context.Context, input models.RegisterInput) (*models.User, error) {
	user, err := r.AuthService.Register(input)
	if err != nil {
		return nil, err
	}
	return user, nil
}

// Login is the resolver for the login mutation.
// It authenticates a user and returns a token by calling the AuthService.
func (r *mutationResolver) Login(ctx context.Context, email string, password string) (*models.AuthResponse, error) {
	token, user, err := r.AuthService.Login(email, password)
	if err != nil {
		return nil, err
	}
	return &models.AuthResponse{Token: token, User: user}, nil
}

// UploadFiles is the resolver for the uploadFiles field.
func (r *mutationResolver) UploadFiles(ctx context.Context, files []*graphql.Upload, parentFolderID *string) ([]*models.File, error) {
	user, err := middleware.GetCurrentUser(ctx)
	if err != nil {
		return nil, err
	}

	var uploadedFiles []*models.File
	for _, file := range files {
		uploadedFile, err := r.FileService.UploadFile(ctx, *file, user, parentFolderID)
		if err != nil {
			// For now, we'll just return the first error we encounter.
			return nil, err
		}
		uploadedFiles = append(uploadedFiles, uploadedFile)
	}

	return uploadedFiles, nil
}

// CreateFolder is the resolver for the createFolder mutation.
// It creates a new folder by calling the FileService.
func (r *mutationResolver) CreateFolder(ctx context.Context, input models.NewFolder) (*models.Folder, error) {
	user, err := middleware.GetCurrentUser(ctx)
	if err != nil {
		return nil, err
	}
	return r.FileService.CreateFolder(ctx, input, user)
}

// UpdateFolder is the resolver for the updateFolder mutation.
// It updates an existing folder's details by calling the FileService.
func (r *mutationResolver) UpdateFolder(ctx context.Context, input models.UpdateFolder) (*models.Folder, error) {
	user, err := middleware.GetCurrentUser(ctx)
	if err != nil {
		return nil, err
	}
	return r.FileService.UpdateFolder(ctx, input, user)
}

// DeleteFolder is the resolver for the deleteFolder mutation.
// It deletes a folder by calling the FileService.
func (r *mutationResolver) DeleteFolder(ctx context.Context, id string) (*models.Folder, error) {
	user, err := middleware.GetCurrentUser(ctx)
	if err != nil {
		return nil, err
	}
	return r.FileService.DeleteFolder(ctx, id, user)
}

// UpdateFile is the resolver for the updateFile mutation.
// It updates a file's metadata by calling the FileService.
func (r *mutationResolver) UpdateFile(ctx context.Context, input models.UpdateFile) (*models.File, error) {
	user, err := middleware.GetCurrentUser(ctx)
	if err != nil {
		return nil, err
	}
	return r.FileService.UpdateFile(ctx, input, user)
}

// DeleteFile is the resolver for the deleteFile mutation.
// It deletes a file by calling the FileService.
func (r *mutationResolver) DeleteFile(ctx context.Context, id string) (*models.File, error) {
	user, err := middleware.GetCurrentUser(ctx)
	if err != nil {
		return nil, err
	}
	return r.FileService.DeleteFile(ctx, id, user)
}

// SetFilePublic is the resolver for the setFilePublic mutation.
// It makes a file public and can only be performed by the file owner.
func (r *mutationResolver) SetFilePublic(ctx context.Context, fileID string) (*models.File, error) {
	user, err := middleware.GetCurrentUser(ctx)
	if err != nil {
		return nil, err
	}
	return r.ShareService.SetFilePublic(ctx, fileID, user)
}

// SetFilePrivate is the resolver for the setFilePrivate mutation.
// It makes a file private and can only be performed by the file owner.
func (r *mutationResolver) SetFilePrivate(ctx context.Context, fileID string) (*models.File, error) {
	user, err := middleware.GetCurrentUser(ctx)
	if err != nil {
		return nil, err
	}
	return r.ShareService.SetFilePrivate(ctx, fileID, user)
}

// ShareFileWithUser is the resolver for the shareFileWithUser mutation.
// It grants another user access to a private file.
// This action can only be performed by the file owner and fails if the file is public.
func (r *mutationResolver) ShareFileWithUser(ctx context.Context, fileID string, userID string) (*models.FileSharing, error) {
	user, err := middleware.GetCurrentUser(ctx)
	if err != nil {
		return nil, err
	}
	return r.ShareService.ShareFileWithUser(ctx, fileID, userID, user)
}

// RemoveFileAccess is the resolver for the removeFileAccess mutation.
// It removes a user's access to a shared file.
// This action can only be performed by the file owner.
func (r *mutationResolver) RemoveFileAccess(ctx context.Context, fileID string, userID string) (bool, error) {
	user, err := middleware.GetCurrentUser(ctx)
	if err != nil {
		return false, err
	}
	return r.ShareService.RemoveFileAccess(ctx, fileID, userID, user)
}

// SetFolderPublic is the resolver for the setFolderPublic mutation.
// It makes a folder public and can only be performed by the folder owner.
func (r *mutationResolver) SetFolderPublic(ctx context.Context, folderID string) (*models.Folder, error) {
	user, err := middleware.GetCurrentUser(ctx)
	if err != nil {
		return nil, err
	}
	return r.ShareService.SetFolderPublic(ctx, folderID, user)
}

// SetFolderPrivate is the resolver for the setFolderPrivate mutation.
// It makes a folder private and can only be performed by the folder owner.
func (r *mutationResolver) SetFolderPrivate(ctx context.Context, folderID string) (*models.Folder, error) {
	user, err := middleware.GetCurrentUser(ctx)
	if err != nil {
		return nil, err
	}
	return r.ShareService.SetFolderPrivate(ctx, folderID, user)
}

// ShareFolderWithUser is the resolver for the shareFolderWithUser mutation.
// It grants another user access to a private folder.
// This action can only be performed by the folder owner and fails if the folder is public.
func (r *mutationResolver) ShareFolderWithUser(ctx context.Context, folderID string, userID string) (*models.FolderSharing, error) {
	user, err := middleware.GetCurrentUser(ctx)
	if err != nil {
		return nil, err
	}
	return r.ShareService.ShareFolderWithUser(ctx, folderID, userID, user)
}

// RemoveFolderAccess is the resolver for the removeFolderAccess mutation.
// It removes a user's access to a shared folder.
// This action can only be performed by the folder owner.
func (r *mutationResolver) RemoveFolderAccess(ctx context.Context, folderID string, userID string) (bool, error) {
	user, err := middleware.GetCurrentUser(ctx)
	if err != nil {
		return false, err
	}
	return r.ShareService.RemoveFolderAccess(ctx, folderID, userID, user)
}

// Me is the resolver for the me query.
// It retrieves the currently authenticated user's information from the context.
func (r *queryResolver) Me(ctx context.Context) (*models.User, error) {
	return middleware.GetCurrentUser(ctx)
}

// Folder is the resolver for the folder query.
// It retrieves a specific folder by its ID for the current user.
func (r *queryResolver) Folder(ctx context.Context, id string) (*models.Folder, error) {
	user, err := middleware.GetCurrentUser(ctx)
	if err != nil {
		return nil, err
	}
	return r.ShareService.GetFolder(ctx, id, user)
}

// Root is the resolver for the root query.
// It retrieves the top-level files and folders for the currently authenticated user.
func (r *queryResolver) Root(ctx context.Context) (*models.Root, error) {
	user, err := middleware.GetCurrentUser(ctx)
	if err != nil {
		return nil, err
	}
	return r.ShareService.GetRoot(ctx, user)
}

// File is the resolver for the file query.
// It retrieves a specific file by its ID for the current user.
func (r *queryResolver) File(ctx context.Context, id string) (*models.File, error) {
	user, err := middleware.GetCurrentUser(ctx)
	if err != nil {
		return nil, err
	}
	return r.ShareService.GetFile(ctx, id, user)
}

// GetUsersWithAccess is the resolver for the getUsersWithAccess query.
// It returns a list of users who have access to a file.
// This includes the file owner and any users the file has been shared with.
// Only the file owner can perform this action.
func (r *queryResolver) GetUsersWithAccess(ctx context.Context, fileID string) ([]*models.User, error) {
	user, err := middleware.GetCurrentUser(ctx)
	if err != nil {
		return nil, err
	}
	return r.ShareService.GetUsersWithAccess(ctx, fileID, user)
}

// SearchFiles is the resolver for the searchFiles query.
// It searches for files based on a set of filters.
func (r *queryResolver) SearchFiles(ctx context.Context, filter *models.FileFilterInput) ([]*models.File, error) {
	user, err := middleware.GetCurrentUser(ctx)
	if err != nil {
		return nil, err
	}
	return r.ShareService.SearchFiles(ctx, filter, user)
}

// StorageStatistics is the resolver for the storageStatistics field.
func (r *subscriptionResolver) StorageStatistics(ctx context.Context, userID *string) (<-chan *models.StorageStatistics, error) {
	currentUser, err := middleware.GetCurrentUser(ctx)
	if err != nil {
		return nil, err
	}

	var targetUserID uint
	if userID != nil {
		if currentUser.Role != "ADMIN" {
			return nil, fmt.Errorf("only admins can view other users' statistics")
		}
		id, _ := strconv.ParseUint(*userID, 10, 64)
		targetUserID = uint(id)
	} else {
		targetUserID = currentUser.ID
	}

	ch := make(chan *models.StorageStatistics, 1)
	channel := fmt.Sprintf("storage_updates_%d", targetUserID)
	pubsub := r.RDB.Subscribe(database.Ctx, channel)

	// Send initial data
	initialStats, err := r.FileService.GetStorageStatistics(targetUserID)
	if err == nil {
		ch <- initialStats
	}

	go func() {
		defer pubsub.Close()
		defer close(ch)

		for {
			select {
			case msg, ok := <-pubsub.Channel():
				if !ok {
					return
				}
				var stats models.StorageStatistics
				if err := json.Unmarshal([]byte(msg.Payload), &stats); err == nil {
					ch <- &stats
				}
			case <-ctx.Done():
				return
			}
		}
	}()

	return ch, nil
}

// ID resolves the id field for the User type.
// It converts the numeric ID of the user object into a string.
func (r *userResolver) ID(ctx context.Context, obj *models.User) (string, error) {
	return strconv.FormatUint(uint64(obj.ID), 10), nil
}

// CreatedAt resolves the createdAt field for the User type.
// It returns the creation timestamp as a string.
func (r *userResolver) CreatedAt(ctx context.Context, obj *models.User) (string, error) {
	return obj.CreatedAt.String(), nil
}

// UpdatedAt resolves the updatedAt field for the User type.
// It returns the last update timestamp as a string.
func (r *userResolver) UpdatedAt(ctx context.Context, obj *models.User) (string, error) {
	return obj.UpdatedAt.String(), nil
}

// StorageQuotaKb resolves the storageQuotaKb field for the User type.
// It returns the user's total storage quota in kilobytes.
func (r *userResolver) StorageQuotaKb(ctx context.Context, obj *models.User) (int32, error) {
	return int32(obj.StorageQuotaKB), nil
}

// UsedStorageKb resolves the usedStorageKb field for the User type.
// It returns the amount of storage the user has currently used in kilobytes.
func (r *userResolver) UsedStorageKb(ctx context.Context, obj *models.User) (int32, error) {
	return int32(obj.UsedStorageKB), nil
}

// SavedStorageKb is the resolver for the savedStorageKb field.
func (r *userResolver) SavedStorageKb(ctx context.Context, obj *models.User) (int32, error) {
	return int32(obj.SavedStorageKB), nil
}

// APIRateLimit resolves the apiRateLimit field for the User type.
// It returns the user's API request rate limit.
func (r *userResolver) APIRateLimit(ctx context.Context, obj *models.User) (int32, error) {
	return int32(obj.APIRateLimit), nil
}

// DeduplicatedContent returns DeduplicatedContentResolver implementation.
func (r *Resolver) DeduplicatedContent() DeduplicatedContentResolver {
	return &deduplicatedContentResolver{r}
}

// File returns FileResolver implementation.
func (r *Resolver) File() FileResolver { return &fileResolver{r} }

// FileSharing returns FileSharingResolver implementation.
func (r *Resolver) FileSharing() FileSharingResolver { return &fileSharingResolver{r} }

// Folder returns FolderResolver implementation.
func (r *Resolver) Folder() FolderResolver { return &folderResolver{r} }

// FolderSharing returns FolderSharingResolver implementation.
func (r *Resolver) FolderSharing() FolderSharingResolver { return &folderSharingResolver{r} }

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Subscription returns SubscriptionResolver implementation.
func (r *Resolver) Subscription() SubscriptionResolver { return &subscriptionResolver{r} }

// User returns UserResolver implementation.
func (r *Resolver) User() UserResolver { return &userResolver{r} }

type deduplicatedContentResolver struct{ *Resolver }
type fileResolver struct{ *Resolver }
type fileSharingResolver struct{ *Resolver }
type folderResolver struct{ *Resolver }
type folderSharingResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }
type userResolver struct{ *Resolver }
